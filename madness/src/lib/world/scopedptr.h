/*
 This file is part of MADNESS.

 Copyright (C) 2007,2010 Oak Ridge National Laboratory

 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

 For more information please contact:

 Robert J. Harrison
 Oak Ridge National Laboratory
 One Bethel Valley Road
 P.O. Box 2008, MS-6367

 email: harrisonrj@ornl.gov
 tel:   865-241-3937
 fax:   865-572-0680


 $Id $
 */

//  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.
//  Copyright (c) 2001, 2002 Peter Dimov
//
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//


#ifndef MADNESS_WORLD_SCOPED_PTR_H__INCLUDED
#define MADNESS_WORLD_SCOPED_PTR_H__INCLUDED

#include <world/worldexc.h>
#include <world/sharedptr.h>
#include <cstddef>

namespace madness {

    // This code is based on Boost scoped_ptr and scoped_array.

    // Forward declarations
    template<typename>
    class ScopedPtr;
    template<typename ptrT>
    inline void swap(ScopedPtr<ptrT>&, ScopedPtr<ptrT>&);
    template<typename ptrT>
    inline ptrT* get_pointer(const ScopedPtr<ptrT>&);


    template<typename>
    class ScopedArray;
    template<typename ptrT>
    inline void swap(ScopedArray<ptrT>&, ScopedArray<ptrT>&);
    template<typename ptrT>
    inline ptrT* get_pointer(const ScopedArray<ptrT>&);

    /// Scoped pointer

    /// Holds a pointer until it goes out of scope, then automatically deletes it.
    /// A scoped pointer should be used to wrap pointers where the lifetime of
    /// the pointer should be limited to a specific scope. The pointer cannot
    /// be copied. The pointer will be deleted with the \c delete operator.
    /// \tparam ptrT The pointer type
    /// \note A pointer to type \c ptrT must be a complete type
    /// \note This class is based on Boost scoped_ptr.
    template<typename ptrT>
    class ScopedPtr {
    private:
        ptrT* ptr_; ///< The pointer

        // Not allowed
        ScopedPtr(const ScopedPtr<ptrT>&);
        ScopedPtr& operator=(const ScopedPtr<ptrT>&);
        void operator==(const ScopedPtr<ptrT>&) const;
        void operator!=(const ScopedPtr<ptrT>&) const;

    public:

        typedef ptrT element_type;  ///< the pointer type

        /// Construct a scoped pointer

        /// \param p The pointer to hold [default = NULL]
        /// \throw nothing
        explicit ScopedPtr(ptrT* p = NULL) : ptr_(p) { }

        /// Destructor

        /// calls \c delete operator
        ~ScopedPtr() { detail::checked_delete<ptrT>(ptr_); }

        /// Reset the current pointer

        /// This will destroy the current pointer. If an new pointer is provided
        /// this pointer will be set to that value.
        /// \param p The pointer that will replace this pointer after deletion
        /// \throw madness::MadnessException If p is the same as this pointer,
        /// except when this pointer is NULL.
        void reset(ptrT* p = NULL)  {
            MADNESS_ASSERT(p == NULL || p != ptr_); // catch self-reset errors
            ScopedPtr<ptrT>(p).swap(*this);
        }

        /// Dereference operator

        /// \return A reference to the pointer's data
        /// \throw madness::MadnessException If the pointer is NULL
        ptrT& operator*() const {
            MADNESS_ASSERT(ptr_ != NULL);
            return *ptr_;
        }

        /// Pointer member accessor

        /// \return The pointer
        /// \throw madness::MadnessException If the pointer is NULL
        ptrT* operator->() const {
            MADNESS_ASSERT(ptr_ != NULL);
            return ptr_;
        }

        /// Pointer accessor

        /// \return The pointer
        /// \throw nothing
        ptrT* get() const { return ptr_; }

        /// \c bool conversion operator

        /// \return pointer != NULL
        /// \throw nothing
        operator bool() const { return (ptr_ != NULL); }

        /// Not operator

        /// \return pointer == NULL
        /// \throw nothing
        bool operator! () const { return (ptr_ == NULL); }

        /// Swap the pointers

        /// \param other The pointer to swap with this pointer
        /// \throw nothing
        void swap(ScopedPtr<ptrT>& other) {
            ptrT* p = ptr_;
            ptr_ = other.ptr_;
            other.ptr_ = p;
        }
    }; // class ScopedPtr

    /// Swap the content of two pointers

    /// \tparam ptrT The pointer type
    /// \param a The scoped pointer to swap with \c b
    /// \param b The scoped poitner to swap with \c a
    /// \throw nothing
    template<typename ptrT>
    inline void swap(ScopedPtr<ptrT>& a, ScopedPtr<ptrT>& b) {
        a.swap(b);
    }

    /// Same as \c p.get()

    /// \tparam ptrT The pointer type
    /// \param p The pointer
    template<typename ptrT>
    inline ptrT* get_pointer(const ScopedPtr<ptrT>& p) {
        return p.get();
    }

    /// Scoped array

    /// Holds a pointer to an array until it goes out of scope, then automatically
    /// deletes it. A scoped array pointer should be used to wrap pointers where
    /// the lifetime of the array pointer should be limited to a specific scope.
    /// The pointer cannot be copied. The pointer will be deleted with the
    /// \c delete operator.
    /// \tparam ptrT The pointer type
    /// \note A pointer to type \c ptrT must be a complete type
    /// \note This class is based on Boost scoped_array.
    template<typename ptrT>
    class ScopedArray {
    private:
        ptrT* ptr_;         ///< The pointer

        // Not allowed
        ScopedArray(const ScopedArray<ptrT>&);
        ScopedArray& operator=(const ScopedArray<ptrT>&);
        void operator==(const ScopedArray<ptrT>&) const;
        void operator!=(const ScopedArray<ptrT>&) const;

    public:

        typedef ptrT element_type;  ///< the pointer type

        /// Construct a scoped pointer

        /// \param p The pointer to hold [default = NULL]
        /// \throw nothing
        explicit ScopedArray(ptrT* p = NULL) : ptr_(p) { }

        /// Destructor

        /// Calls \c delete[] operator
        ~ScopedArray() { detail::checked_array_delete<ptrT>(ptr_); }

        /// Reset the current pointer

        /// This will destroy the current pointer. If an new pointer is provided
        /// this pointer will be set to that value.
        /// \param p The array pointer that will replace this pointer after deletion
        /// \throw madness::MadnessException If p is the same as this pointer,
        /// except when this pointer is NULL.
        void reset(ptrT* p = NULL)  {
            MADNESS_ASSERT(p == NULL || p != ptr_); // catch self-reset errors
            ScopedArray<ptrT>(p).swap(*this);
        }

        /// Array element accessor

        /// \return The pointer
        /// \throw madness::MadnessException If the pointer is NULL
        ptrT& operator[](std::size_t i) const {
            MADNESS_ASSERT(ptr_ != NULL);
            return ptr_[i];
        }

        /// Pointer accessor

        /// \return The pointer
        /// \throw nothing
        ptrT* get() const { return ptr_; }

        /// \c bool conversion operator

        /// \return pointer != NULL
        /// \throw nothing
        operator bool() const { return (ptr_ != NULL); }

        /// Not operator

        /// \return pointer == NULL
        /// \throw nothing
        bool operator! () const { return (ptr_ == NULL); }

        /// Swap the pointers

        /// \param other The pointer to swap with this pointer
        /// \throw nothing
        void swap(ScopedArray<ptrT>& other) {
            ptrT* p = ptr_;
            ptr_ = other.ptr_;
            other.ptr_ = p;
        }
    }; // class ScopedArray

    /// Swap the content of two arrays

    /// \tparam ptrT The pointer type
    /// \param a The scoped array to swap with \c b
    /// \param b The scoped array to swap with \c a
    /// \throw nothing
    template<typename ptrT>
    inline void swap(ScopedArray<ptrT>& a, ScopedArray<ptrT>& b) {
        a.swap(b);
    }

    /// Same as \c p.get()

    /// \tparam ptrT The pointer type
    /// \param p The pointer
    /// \throw nothing
    template<typename ptrT>
    inline ptrT* get_pointer(const ScopedArray<ptrT>& p) {
        return p.get();
    }

} // namespace madness

#endif // MADNESS_WORLD_SCOPED_PTR_H__INCLUDED
